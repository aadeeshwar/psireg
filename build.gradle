plugins {
    id 'base'
}

description = 'Predictive Swarm Intelligence for Renewable Energy Grids'
version = '0.1.0'

// Define directories
def srcDir = 'src'
def testsDir = 'tests'
def docsDir = 'docs'
def buildDir = 'build'
def htmlCovDir = 'htmlcov'

// Helper function to check if poetry lock file is in sync
def checkPoetryLockSync() {
    def lockFile = file('poetry.lock')
    def projectFile = file('pyproject.toml')
    
    if (!lockFile.exists()) {
        logger.warn("poetry.lock file does not exist")
        return false
    }
    
    if (!projectFile.exists()) {
        logger.warn("pyproject.toml file does not exist") 
        return false
    }
    
    return lockFile.lastModified() >= projectFile.lastModified()
}

// Helper function to execute poetry commands with error handling
def poetryExec(String command) {
    def args = ['poetry', 'run']
    args.addAll(command.split(' '))
    exec {
        commandLine args
        environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
    }
}

def poetryExecCatch(String command) {
    try {
        def args = ['poetry', 'run']
        args.addAll(command.split(' '))
        exec {
            commandLine args
            environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
        }
        return true
    } catch (Exception e) {
        // Check if it's a pytest "no tests collected" error (exit code 5)
        if (e.toString().contains('finished with non-zero exit value 5')) {
            logger.info("No tests found for: poetry run ${command}")
            return true
        }
        logger.warn("Command failed: poetry run ${command}")
        return false
    }
}

// Enhanced install task with lock file handling
task install {
    group = 'setup'
    description = 'Install project dependencies using Poetry'
    
    doLast {
        if (!checkPoetryLockSync()) {
            logger.warn("poetry.lock is out of sync with pyproject.toml")
            logger.warn("Attempting to update lock file...")
        }
        
        // Try to install dependencies
        try {
            exec {
                commandLine 'poetry', 'install'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            logger.info("Poetry install completed successfully!")
        } catch (Exception e) {
            logger.error("Poetry install failed: ${e.message}")
            
            // Try to fix lock file sync issue
            try {
                logger.info("Attempting to update poetry lock file...")
                exec {
                    commandLine 'poetry', 'lock'
                    environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
                }
                
                // Retry install after lock update
                logger.info("Retrying poetry install...")
                exec {
                    commandLine 'poetry', 'install'
                    environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
                }
                logger.info("Poetry install succeeded after lock file update")
            } catch (Exception e2) {
                logger.error("Failed to update lock file or install dependencies")
                logger.error("This might be due to network connectivity issues")
                logger.info("Trying to continue with existing environment...")
                
                // Check if we can at least validate the project structure
                if (!file("${srcDir}/psireg").exists()) {
                    throw new RuntimeException("Source code not found in ${srcDir}/psireg")
                }
                logger.info("Source code structure validated, continuing build...")
            }
        }
    }
}

// Install visualization dependencies
task installViz(type: Exec) {
    group = 'setup'
    description = 'Install visualization dependencies (pandas, plotly, numpy) using Poetry'
    commandLine 'poetry', 'add', 'pandas', 'plotly', 'numpy'
    environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
    ignoreExitValue = true
}

// Install visualization dependencies as optional group
task installVizOptional(type: Exec) {
    group = 'setup'
    description = 'Install visualization dependencies as optional group'
    commandLine 'poetry', 'add', '--group', 'viz', 'pandas', 'plotly', 'numpy'
    environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
    ignoreExitValue = true
}

// Enhanced code formatting with fallback
task fmt {
    group = 'formatting'
    description = 'Format code using black'
    dependsOn install
    doLast {
        try {
            poetryExec("black ${srcDir} ${testsDir}")
        } catch (Exception e) {
            logger.warn("Code formatting failed, but continuing build...")
            logger.info("You may need to run 'poetry install' to install black")
        }
    }
}

task fmtCheck {
    group = 'formatting'
    description = 'Check code formatting using black'
    dependsOn install
    doLast {
        try {
            poetryExec("black --check ${srcDir} ${testsDir}")
        } catch (Exception e) {
            logger.warn("Code format check failed, but continuing build...")
            logger.info("Run 'gradle fmt' to format the code")
        }
    }
}

// Enhanced linting with fallback
task lint {
    group = 'quality'
    description = 'Run linting using ruff'
    dependsOn install
    doLast {
        try {
            poetryExec("ruff check ${srcDir} ${testsDir}")
        } catch (Exception e) {
            logger.warn("Linting failed, but continuing build...")
            logger.info("You may need to run 'poetry install' to install ruff")
        }
    }
}

task lintFix {
    group = 'quality'
    description = 'Run linting and fix issues using ruff'
    dependsOn install
    doLast {
        try {
            poetryExec("ruff check --fix ${srcDir} ${testsDir}")
        } catch (Exception e) {
            logger.warn("Lint fixing failed, but continuing build...")
        }
    }
}

// Enhanced type checking with fallback
task type {
    group = 'quality'
    description = 'Run type checking using mypy'
    dependsOn install
    doLast {
        try {
            poetryExec("mypy ${srcDir}")
        } catch (Exception e) {
            logger.warn("Type checking failed, but continuing build...")
            logger.info("You may need to run 'poetry install' to install mypy")
        }
    }
}

// Enhanced testing with fallback
task testUnit {
    group = 'testing'
    description = 'Run unit tests'
    dependsOn install
    doLast {
        try {
            def args = ['poetry', 'run', 'pytest', '-m', 'unit', testsDir]
            exec {
                commandLine args
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            if (!e.toString().contains('finished with non-zero exit value 5')) {
                logger.warn("Unit tests failed, but continuing build...")
            } else {
                logger.info("No unit tests found")
            }
        }
    }
}

task testIntegration {
    group = 'testing'
    description = 'Run integration tests'
    dependsOn install
    doLast {
        try {
            def args = ['poetry', 'run', 'pytest', '-m', 'integration', testsDir]
            exec {
                commandLine args
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            if (!e.toString().contains('finished with non-zero exit value 5')) {
                logger.warn("Integration tests failed, but continuing build...")
            } else {
                logger.info("No integration tests found")
            }
        }
    }
}

task testAcceptance {
    group = 'testing'
    description = 'Run acceptance tests'
    dependsOn install
    doLast {
        try {
            def args = ['poetry', 'run', 'pytest', '-m', 'acceptance', testsDir]
            exec {
                commandLine args
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            if (!e.toString().contains('finished with non-zero exit value 5')) {
                logger.warn("Acceptance tests failed, but continuing build...")
            } else {
                logger.info("No acceptance tests found")
            }
        }
    }
}

task test {
    group = 'testing'
    description = 'Run all tests'
    dependsOn install
    doLast {
        try {
            def args = ['poetry', 'run', 'pytest', testsDir]
            exec {
                commandLine args
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            if (!e.toString().contains('finished with non-zero exit value 5')) {
                logger.warn("Tests failed, but continuing build...")
            } else {
                logger.info("No tests found")
            }
        }
    }
}

// Coverage
task cov {
    group = 'testing'
    description = 'Run tests with coverage reporting'
    dependsOn install
    doLast {
        try {
            def args = ['poetry', 'run', 'pytest', "--cov=${srcDir}", '--cov-report=html', '--cov-report=term-missing', testsDir]
            exec {
                commandLine args
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            if (!e.toString().contains('finished with non-zero exit value 5')) {
                logger.warn("Coverage tests failed, but continuing build...")
            } else {
                logger.info("No tests found for coverage")
            }
        }
    }
}

task covReport {
    group = 'testing'
    description = 'Generate coverage report'
    dependsOn cov
    doLast {
        println "Coverage report generated in ${htmlCovDir}/index.html"
    }
}

// Documentation
task docsInit {
    group = 'documentation'
    description = 'Initialize Sphinx documentation'
    dependsOn install
    doLast {
        mkdir docsDir
        try {
            exec {
                workingDir docsDir
                commandLine 'poetry', 'run', 'sphinx-quickstart', '--quiet', '--project', 'psireg', 
                            '--author', 'Aadeeshwar Pathak', '--release', '0.1.0', '--language', 'en', 
                            '--suffix', '.rst', '--master', 'index', '--epub', '--makefile', 
                            '--batchfile', '--sep', '.'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            logger.warn("Documentation initialization failed, but continuing build...")
        }
    }
}

task docs {
    group = 'documentation'
    description = 'Generate documentation using Sphinx'
    dependsOn install
    doLast {
        if (!file(docsDir).exists()) {
            dependsOn docsInit
        }
        try {
            exec {
                workingDir docsDir
                commandLine 'poetry', 'run', 'sphinx-build', '-b', 'html', 'source', 'build'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
        } catch (Exception e) {
            logger.warn("Documentation generation failed, but continuing build...")
        }
    }
}

// Validate project structure
task validateProject {
    group = 'validation'
    description = 'Validate project structure and essential files'
    doLast {
        def requiredFiles = [
            'pyproject.toml',
            'README.md',
            "${srcDir}/psireg/__init__.py",
            "${testsDir}/__init__.py"
        ]
        
        def requiredDirs = [
            srcDir,
            testsDir,
            "${srcDir}/psireg",
            "${srcDir}/psireg/sim",
            "${srcDir}/psireg/swarm"
        ]
        
        logger.info("Validating project structure...")
        
        // Check required files
        requiredFiles.each { fileName ->
            def file = file(fileName)
            if (!file.exists()) {
                throw new RuntimeException("Required file missing: ${fileName}")
            }
            logger.info("✓ Found: ${fileName}")
        }
        
        // Check required directories
        requiredDirs.each { dirName ->
            def dir = file(dirName)
            if (!dir.exists() || !dir.isDirectory()) {
                throw new RuntimeException("Required directory missing: ${dirName}")
            }
            logger.info("✓ Found: ${dirName}/")
        }
        
        logger.info("Project structure validation passed!")
    }
}

// Build with enhanced error handling
task buildProject {
    group = 'build'
    description = 'Build the project with enhanced error handling'
    dependsOn validateProject, install
    
    doLast {
        // Run quality checks directly with poetry commands
        logger.info("Running quality checks...")
        
        // Code formatting
        try {
            logger.info("Running code formatting...")
            exec {
                commandLine 'poetry', 'run', 'black', 'src', 'tests'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            logger.info("✓ Code formatting completed")
        } catch (Exception e) {
            logger.warn("✗ Code formatting failed: ${e.message}")
        }
        
        // Linting
        logger.info("Running linting...")
        exec {
            commandLine 'poetry', 'run', 'ruff', 'check', 'src', 'tests'
            environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
        }
        logger.info("✓ Linting completed")
        
        // Type checking
        try {
            logger.info("Running type checking...")
            exec {
                commandLine 'poetry', 'run', 'mypy', 'src'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            logger.info("✓ Type checking completed")
        } catch (Exception e) {
            logger.warn("✗ Type checking failed: ${e.message}")
        }
        
        // Testing
        logger.info("Running tests...")
        exec {
            commandLine 'poetry', 'run', 'pytest', 'tests'
            environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
        }
        logger.info("✓ Tests completed")
        
        // Build with poetry
        try {
            logger.info("Building package...")
            exec {
                commandLine 'poetry', 'build'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            logger.info("✓ Package build completed successfully!")
        } catch (Exception e) {
            logger.warn("✗ Package build failed: ${e.message}")
            logger.info("Project structure is valid and ready for development")
        }
        
        logger.info("Build process completed!")
    }
}

// Override the default build task to use our buildProject
build.dependsOn buildProject

// Clean
task cleanProject {
    group = 'build'
    description = 'Clean build artifacts'
    doLast {
        delete buildDir
        delete htmlCovDir
        delete 'dist'
        delete '.pytest_cache'
        delete '.mypy_cache'
        delete '.ruff_cache'
        delete '.coverage'
        fileTree('.').matching {
            include '**/__pycache__'
            include '**/*.pyc'
            include '**/*.pyo'
        }.each { delete it }
    }
}

// Override the default clean task to use our cleanProject
clean.dependsOn cleanProject

// Quality check task (runs all quality checks)
task checkProject {
    group = 'verification'
    description = 'Run all quality checks with graceful error handling'
    dependsOn validateProject, install
    
    doLast {
        def passedChecks = []
        def failedChecks = []
        
        // Format check
        try {
            logger.info("Running format check...")
            exec {
                commandLine 'poetry', 'run', 'black', '--check', 'src', 'tests'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            passedChecks.add('format')
            logger.info("✓ Format check passed")
        } catch (Exception e) {
            failedChecks.add('format')
            logger.warn("✗ Format check failed")
        }
        
        // Lint check
        logger.info("Running lint check...")
        exec {
            commandLine 'poetry', 'run', 'ruff', 'check', 'src', 'tests'
            environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
        }
        passedChecks.add('lint')
        logger.info("✓ Lint check passed")
        
        // Type check
        try {
            logger.info("Running type check...")
            exec {
                commandLine 'poetry', 'run', 'mypy', 'src'
                environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
            }
            passedChecks.add('type')
            logger.info("✓ Type check passed")
        } catch (Exception e) {
            failedChecks.add('type')
            logger.warn("✗ Type check failed")
        }
        
        // Test check
        logger.info("Running test check...")
        exec {
            commandLine 'poetry', 'run', 'pytest', 'tests'
            environment 'REQUESTS_CA_BUNDLE', '/tmp/tesco_ca.pem'
        }
        passedChecks.add('test')
        logger.info("✓ Test check passed")
        
        logger.info("Quality check summary:")
        logger.info("Passed: ${passedChecks.join(', ')}")
        if (!failedChecks.isEmpty()) {
            logger.warn("Failed: ${failedChecks.join(', ')}")
            logger.warn("Some quality checks failed, but build can continue")
        }
    }
}

// Override the default check task to use our checkProject
check.dependsOn checkProject

// Visualization demo
task vizDemo {
    group = 'visualization'
    description = 'Run visualization demo with interactive dashboards'
    dependsOn install
    doLast {
        try {
            poetryExec("python examples/visualization_demo.py")
        } catch (Exception e) {
            logger.warn("Visualization demo failed. Make sure visualization dependencies are installed with: gradle installViz")
            throw e
        }
    }
}

task realSimDemo {
    group = 'visualization'
    description = 'Run real PSIREG simulation demo'
    dependsOn install
    doLast {
        try {
            poetryExec("python examples/real_simulation_demo.py")
        } catch (Exception e) {
            logger.warn("Real simulation demo failed: ${e.message}")
        }
    }
}

// Development setup
task dev {
    group = 'development'
    description = 'Set up development environment'
    dependsOn validateProject, install
    doLast {
        println "Development environment ready!"
        println "Available tasks:"
        println "  - validateProject: Validate project structure"
        println "  - fmt: Format code"
        println "  - lint: Run linting"
        println "  - type: Run type checking"
        println "  - test: Run tests"
        println "  - cov: Run tests with coverage"
        println "  - build: Build the project"
        println "  - docs: Generate documentation"
        println "  - check: Run all quality checks"
        println "  - installViz: Install visualization dependencies"
        println "  - vizDemo: Run visualization demo"
        println "  - realSimDemo: Run real simulation demo"
    }
}

// Default task
defaultTasks 'dev'

// Task dependencies for CI/CD
task ci {
    group = 'ci'
    description = 'Run CI pipeline with enhanced error handling'
    dependsOn cleanProject, validateProject, install, checkProject, buildProject
}

// Configure task execution order
validateProject.shouldRunAfter cleanProject
install.shouldRunAfter validateProject
checkProject.shouldRunAfter install
buildProject.shouldRunAfter checkProject 